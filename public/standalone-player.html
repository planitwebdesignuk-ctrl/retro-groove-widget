<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vintage Vinyl Player - Standalone</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, #1a1612 0%, #2d2418 100%);
      color: #e8d7c3;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }

    .container {
      width: 100%;
      max-width: 900px;
      animation: fadeIn 0.8s ease-out;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .turntable {
      position: relative;
      width: 100%;
      border-radius: 1.5rem;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      overflow: hidden;
      aspect-ratio: 1.18;
    }

    .turntable-base {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: cover;
    }

    .platter {
      position: absolute;
      aspect-ratio: 1/1;
      z-index: 2;
      /* Position and size set dynamically via JavaScript */
    }

    .vinyl {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      transition: transform 0.5s ease;
    }

    .vinyl img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .vinyl.spinning {
      animation: spin 25s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .tonearm {
      position: absolute;
      height: auto;
      transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.4));
      z-index: 3;
      /* Position and transform-origin set dynamically via JavaScript */
    }

    .tonearm.no-transition {
      transition: none !important;
    }

    .tonearm img {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
    }

    .glow {
      position: absolute;
      background: radial-gradient(circle, rgba(234, 88, 12, 0.2), transparent 70%);
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.5s;
      pointer-events: none;
      animation: pulse 2s ease-in-out infinite;
      z-index: 1;
      /* Position and size set dynamically via JavaScript */
    }

    .glow.active {
      opacity: 1;
    }

    @keyframes pulse {
      0%, 100% { 
        opacity: 0.6;
      }
      50% { 
        opacity: 1;
      }
    }

    .controls {
      margin-top: 2rem;
      background: rgba(45, 36, 24, 0.8);
      backdrop-filter: blur(10px);
      border-radius: 1rem;
      padding: 2rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .track-info {
      text-align: center;
      margin-bottom: 1.5rem;
    }

    .track-title {
      font-size: 1.5rem;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }

    .track-artist {
      color: #a89075;
      font-size: 0.9rem;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: rgba(168, 144, 117, 0.2);
      border-radius: 999px;
      overflow: hidden;
      margin-bottom: 1.5rem;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #c77d3a, #ea580c);
      width: 0%;
      transition: width 0.3s;
    }

    .buttons {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    button {
      background: rgba(199, 125, 58, 0.2);
      border: 2px solid #c77d3a;
      color: #e8d7c3;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
    }

    button:hover:not(:disabled) {
      background: rgba(199, 125, 58, 0.4);
      transform: scale(1.05);
    }

    button:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    button.small {
      width: 48px;
      height: 48px;
    }

    button.large {
      width: 64px;
      height: 64px;
      background: #c77d3a;
      border-color: #ea580c;
    }

    button.large:hover:not(:disabled) {
      background: #ea580c;
    }

    .playlist {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .track-item {
      background: rgba(168, 144, 117, 0.1);
      border: none;
      border-radius: 0.5rem;
      padding: 0.75rem 1rem;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 1rem;
      text-align: left;
      width: 100%;
    }

    .track-item:hover {
      background: rgba(168, 144, 117, 0.2);
    }

    .track-item.active {
      background: rgba(199, 125, 58, 0.3);
      border: 1px solid #c77d3a;
    }

    .track-number {
      font-weight: bold;
      opacity: 0.7;
      min-width: 1.5rem;
    }

    .track-details {
      flex: 1;
    }

    .track-details .title {
      font-weight: 500;
      font-size: 0.9rem;
    }

    .track-details .artist {
      font-size: 0.75rem;
      opacity: 0.7;
      margin-top: 0.25rem;
    }

    .visualizer {
      display: flex;
      gap: 2px;
      align-items: flex-end;
    }

    .visualizer span {
      width: 3px;
      height: 12px;
      background: #c77d3a;
      animation: wave 0.8s ease-in-out infinite;
    }

    .visualizer span:nth-child(2) { animation-delay: 0.1s; }
    .visualizer span:nth-child(3) { animation-delay: 0.2s; }

    @keyframes wave {
      0%, 100% { height: 6px; }
      50% { height: 16px; }
    }

    /* Calibration Mode Styles */
    .calibration-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 10;
    }

    .reference-image {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 5;
    }

    .calibration-guides {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .platter-ring {
      position: absolute;
      border: 2px solid #facc15;
      border-radius: 50%;
    }

    .tonearm-pivot {
      position: absolute;
    }

    .crosshair-h, .crosshair-v {
      position: absolute;
      background: #ef4444;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }

    .crosshair-h {
      width: 32px;
      height: 2px;
    }

    .crosshair-v {
      width: 2px;
      height: 32px;
    }

    .crosshair-dot {
      position: absolute;
      width: 8px;
      height: 8px;
      border: 2px solid #ef4444;
      border-radius: 50%;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }

    .calibration-panel {
      position: absolute;
      top: 1rem;
      left: 1rem;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 1rem;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      max-width: 400px;
      pointer-events: auto;
      z-index: 20;
    }

    .panel-title {
      font-weight: bold;
      margin-bottom: 0.75rem;
      font-size: 13px;
    }

    .config-values {
      margin-bottom: 0.75rem;
      line-height: 1.6;
    }

    .config-values > div {
      transition: color 0.2s;
    }

    .config-values > div.active {
      color: #facc15;
      font-weight: bold;
    }

    .controls-help {
      margin-bottom: 0.75rem;
      font-size: 10px;
      color: #d1d5db;
      line-height: 1.5;
      padding-top: 0.75rem;
      border-top: 1px solid #374151;
    }

    .reference-controls {
      margin-bottom: 0.75rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid #374151;
    }

    .reference-controls button {
      width: 100%;
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      font-size: 11px;
    }

    .reference-controls label {
      display: block;
      font-size: 10px;
      margin-bottom: 0.25rem;
    }

    .reference-controls input[type="range"] {
      width: 100%;
    }

    .action-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .action-buttons button {
      flex: 1;
      padding: 0.5rem;
      font-size: 11px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .btn-upload {
      background: #2563eb;
    }

    .btn-upload:hover {
      background: #1d4ed8;
    }

    .btn-copy {
      background: #16a34a;
      color: white;
    }

    .btn-copy:hover {
      background: #15803d;
    }

    .btn-reset {
      background: #ea580c;
      color: white;
    }

    .btn-reset:hover {
      background: #c2410c;
    }

    .btn-exit {
      background: #dc2626;
      color: white;
    }

    .btn-exit:hover {
      background: #b91c1c;
    }

    @media (max-width: 768px) {
      body {
        padding: 1rem;
      }
      .track-title {
        font-size: 1.2rem;
      }
      button.large {
        width: 56px;
        height: 56px;
      }
      button.small {
        width: 40px;
        height: 40px;
      }
      .calibration-panel {
        max-width: calc(100% - 2rem);
        font-size: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="turntable">
      <img src="/images/turntable-base.png" alt="Turntable" class="turntable-base">
      <div class="platter">
        <div class="vinyl" id="vinyl">
          <img src="/images/vinyl-record.png" alt="Vinyl Record">
        </div>
      </div>
      <div class="tonearm" id="tonearm">
        <img src="/images/tonearm-animated.png" alt="Tonearm">
      </div>
      <div class="glow" id="glow"></div>
    </div>

    <div class="controls">
      <div class="track-info">
        <div class="track-title" id="trackTitle">Loading...</div>
        <div class="track-artist" id="trackArtist">...</div>
      </div>

      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>

      <div class="buttons">
        <button class="small" id="prevBtn" title="Previous">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polygon points="19 20 9 12 19 4 19 20"></polygon>
            <line x1="5" y1="19" x2="5" y2="5"></line>
          </svg>
        </button>
        
        <button class="large" id="playBtn" title="Play" style="display: block;">
          <svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
            <polygon points="5 3 19 12 5 21 5 3"></polygon>
          </svg>
        </button>
        
        <button class="large" id="stopBtn" title="Stop" style="display: none;">
          <svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
            <rect x="6" y="6" width="12" height="12"></rect>
          </svg>
        </button>
        
        <button class="small" id="nextBtn" title="Next">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polygon points="5 4 15 12 5 20 5 4"></polygon>
            <line x1="19" y1="5" x2="19" y2="19"></line>
          </svg>
        </button>
      </div>

      <div class="playlist" id="playlist"></div>
    </div>

    <audio id="audio" preload="metadata"></audio>

    <!-- Calibration Overlay -->
    <div id="calibrationOverlay" class="calibration-overlay" style="display: none;">
      <img id="referenceImage" class="reference-image" style="display: none;" />
      <div class="calibration-guides">
        <div class="platter-ring" id="platterRing"></div>
        <div class="tonearm-pivot" id="tonearmPivot">
          <div class="crosshair-h"></div>
          <div class="crosshair-v"></div>
          <div class="crosshair-dot"></div>
        </div>
      </div>
      <div class="calibration-panel">
        <div class="panel-title">ðŸŽ¯ Calibration Mode</div>
        <div class="config-values">
          <div id="platterInfo">Platter: L:0% T:0% Size:0%</div>
          <div id="tonearmInfo">Tonearm: R:0% T:0% W:0% H:0%</div>
          <div id="pivotInfo">Pivot: X:0% Y:0%</div>
          <div id="anglesInfo">Angles: REST:0Â° START:0Â° END:0Â°</div>
        </div>
        <div class="controls-help">
          <div>Tab: Switch target (<span id="currentTarget">platter</span>)</div>
          <div>Arrows: Move/Adjust (Shift=1.0, Alt=0.02)</div>
          <div>[ ]: Tonearm Height/Size/END angle</div>
          <div>+/-: Tonearm Width</div>
          <div>ESC: Exit calibration</div>
        </div>
        <div class="reference-controls">
          <input type="file" id="refImageInput" accept="image/*" style="display: none;" />
          <button onclick="document.getElementById('refImageInput').click()" class="btn-upload">
            ðŸ“¤ Upload Reference
          </button>
          <div id="opacityControl" style="display: none;">
            <label>Opacity: <span id="opacityValue">50</span>%</label>
            <input type="range" id="opacitySlider" min="0" max="100" value="50" />
          </div>
        </div>
        <div class="action-buttons">
          <button onclick="copyConfig()" class="btn-copy">ðŸ“‹ Copy</button>
          <button onclick="resetConfig()" class="btn-reset">ðŸ”„ Reset</button>
        </div>
        <div class="action-buttons" style="margin-top: 0.5rem;">
          <button onclick="forceDefaults()" style="background: #7c3aed; color: white;">âš¡ Force Defaults</button>
          <button onclick="exitCalibration()" class="btn-exit">Exit</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============ CONFIGURATION ============
    const DEFAULT_CONFIG = {
      configVersion: 6,
      platter: {
        leftPct: 12.9,
        topPct: 10.7,
        sizePct: 55.8,
      },
      tonearm: {
        rightPct: 18.0,
        topPct: 10.1,
        widthPct: 17.1,
        lengthScale: 1.20,
        pivotXPct: 87.9,
        pivotYPct: 9.8,
      },
      angles: {
        REST: -0.6,
        START: 14.0,
        END: 30.9,
      },
    };

    const STORAGE_KEY = 'vinyl-player-config-v6';

    // Load CONFIG from localStorage or use defaults
    let CONFIG = (() => {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const parsed = JSON.parse(saved);
        // Version check: ignore saved config if version doesn't match
        if (parsed.configVersion === DEFAULT_CONFIG.configVersion) {
          return parsed;
        }
      }
      return JSON.parse(JSON.stringify(DEFAULT_CONFIG));
    })();

    // Playlist data (easily replaceable with API/database)
    const tracks = [
      { id: 1, title: "You Could Be My Angel", artist: "Live Performance", url: "/audio/You_Could_Be_My_Angel_Live.mp3" },
      { id: 2, title: "Soul Survivor", artist: "Original Recording", url: "/audio/Soul_Survivor.mp3" },
      { id: 3, title: "Piece of What it Takes", artist: "Studio Version", url: "/audio/Piece_of_What_it_Takes.mp3" },
      { id: 4, title: "Mama Said", artist: "Live Performance", url: "/audio/Mama_Said_Live.mp3" },
      { id: 5, title: "Gotta Roll", artist: "Live Performance", url: "/audio/Gotta_Roll_Live.mp3" },
      { id: 6, title: "Don't Mind", artist: "Original Recording", url: "/audio/Don_t_Mind.mp3" },
      { id: 7, title: "Come With Me", artist: "Studio Version", url: "/audio/Come_With_Me.mp3" }
    ];

    // Store actual track durations (loaded dynamically)
    let trackDurations = [];

    // Load actual track durations with metadata preloading
    function loadTrackDurations() {
      const promises = tracks.map((track, index) => {
        return new Promise((resolve) => {
          const tempAudio = new Audio();
          tempAudio.preload = 'metadata';
          tempAudio.src = track.url;
          tempAudio.addEventListener('loadedmetadata', () => {
            trackDurations[index] = tempAudio.duration;
            resolve();
          });
          tempAudio.addEventListener('error', () => {
            trackDurations[index] = 0; // Fallback on error
            resolve();
          });
        });
      });
      return Promise.all(promises);
    }

    // Check if durations are ready
    function durationsReady() {
      return trackDurations.length === tracks.length && trackDurations.every(d => d > 0);
    }

    // Compute per-track angle fractions
    function computeTrackFractions() {
      const n = tracks.length;
      if (!durationsReady() || n === 0) {
        // Equal split when durations not ready
        return Array.from({ length: n }, (_, i) => ({
          start: i / n,
          end: (i + 1) / n,
        }));
      }
      // Proportional split based on durations
      const total = trackDurations.reduce((a, b) => a + b, 0);
      let acc = 0;
      return trackDurations.map((d) => {
        const start = total > 0 ? acc / total : 0;
        acc += d;
        const end = total > 0 ? acc / total : 1 / n;
        return { start, end };
      });
    }

    // Load durations on page load
    Promise.all([loadTrackDurations()]).then(() => {
      console.log('Track durations loaded:', trackDurations);
      updateTonearm(); // Update tonearm once durations are ready
    });

    // ============ DOM ELEMENTS ============
    const audio = document.getElementById('audio');
    const vinyl = document.getElementById('vinyl');
    const tonearm = document.getElementById('tonearm');
    const glow = document.getElementById('glow');
    const playBtn = document.getElementById('playBtn');
    const stopBtn = document.getElementById('stopBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const trackTitle = document.getElementById('trackTitle');
    const trackArtist = document.getElementById('trackArtist');
    const progressFill = document.getElementById('progressFill');
    const playlistEl = document.getElementById('playlist');

    // ============ STATE ============
    let currentTrackIndex = 0;
    let isPlaying = false;
    let isStartingPlayback = false;
    let snapTonearm = false;

    // ============ FUNCTIONS ============
    function loadTrack(index) {
      const track = tracks[index];
      audio.src = track.url;
      audio.currentTime = 0;
      trackTitle.textContent = track.title;
      trackArtist.textContent = track.artist;
      updatePlaylist();
      updateButtons();
      updateTonearm();
    }

    function playTrack() {
      // Set flags to ensure tonearm snaps to START position instantly
      snapTonearm = true;
      isStartingPlayback = true;
      
      // Disable transition temporarily
      tonearm.classList.add('no-transition');
      
      const startPlayback = () => {
        audio.play()
          .then(() => {
            isPlaying = true;
            vinyl.classList.add('spinning');
            glow.classList.add('active');
            playBtn.style.display = 'none';
            stopBtn.style.display = 'block';
            updateTonearm();
            
            // Re-enable transition after snap completes
            requestAnimationFrame(() => {
              snapTonearm = false;
              tonearm.classList.remove('no-transition');
            });
            
            // Reset isStartingPlayback after a short delay
            setTimeout(() => {
              isStartingPlayback = false;
            }, 200);
          })
          .catch((error) => {
            console.error('Playback failed:', error);
            snapTonearm = false;
            isStartingPlayback = false;
            tonearm.classList.remove('no-transition');
          });
      };
      
      // Wait for audio to be ready before starting
      if (audio.readyState >= 3) { // HAVE_FUTURE_DATA or better
        startPlayback();
      } else {
        const handleCanPlay = () => {
          audio.removeEventListener('canplay', handleCanPlay);
          startPlayback();
        };
        audio.addEventListener('canplay', handleCanPlay);
        audio.load(); // Ensure loading starts
      }
    }

    function stopTrack() {
      audio.pause();
      audio.currentTime = 0;
      progressFill.style.width = '0%';
      isPlaying = false;
      vinyl.classList.remove('spinning');
      glow.classList.remove('active');
      playBtn.style.display = 'block';
      stopBtn.style.display = 'none';
      updateTonearm();
    }

    function prevTrack() {
      const wasPlaying = isPlaying;
      
      if (currentTrackIndex > 0) {
        currentTrackIndex--;
        loadTrack(currentTrackIndex);
        // Keep playing if it was playing
        if (wasPlaying) {
          setTimeout(() => playTrack(), 50); // Small delay to let track load
        }
      } else {
        // Stay at track 0, just reset position
        audio.currentTime = 0;
        progressFill.style.width = '0%';
        updateTonearm();
      }
    }

    function nextTrack() {
      const wasPlaying = isPlaying;
      
      if (currentTrackIndex < tracks.length - 1) {
        currentTrackIndex++;
      } else {
        // Wrap to first track
        currentTrackIndex = 0;
      }
      loadTrack(currentTrackIndex);
      // Keep playing if it was playing
      if (wasPlaying) {
        setTimeout(() => playTrack(), 50); // Small delay to let track load
      }
    }

    // Calculate global fraction based on current track segment
    function getGlobalFraction() {
      const fractions = computeTrackFractions();
      const f = fractions[currentTrackIndex] || { start: 0, end: 1 / tracks.length };
      const within = (audio.duration ? audio.currentTime / audio.duration : 0);
      const span = Math.max(0, f.end - f.start);
      return f.start + within * span;
    }

    function updateTonearm() {
      let angle;
      
      // When not playing, tonearm returns to REST position
      if (!isPlaying) {
        angle = CONFIG.angles.REST;
      } else if (snapTonearm || isStartingPlayback) {
        // If snapping or just starting playback, use the track's start position
        if (currentTrackIndex === 0) {
          angle = CONFIG.angles.START; // 16.0Â°
        } else {
          const fractions = computeTrackFractions();
          const trackStart = fractions[currentTrackIndex]?.start || 0;
          angle = CONFIG.angles.START + (CONFIG.angles.END - CONFIG.angles.START) * trackStart;
        }
      } else {
        // Safety check: ensure audio is ready with valid duration
        if (!audio.duration || isNaN(audio.duration)) {
          // If audio isn't ready but we're "playing", use track start position
          if (currentTrackIndex === 0) {
            angle = CONFIG.angles.START; // 16.0Â°
          } else {
            const fractions = computeTrackFractions();
            const trackStart = fractions[currentTrackIndex]?.start || 0;
            angle = CONFIG.angles.START + (CONFIG.angles.END - CONFIG.angles.START) * trackStart;
          }
        } else if (audio.currentTime < 0.1) {
          // If at the very start of a track (within first 100ms), use the track's start position
          // Track 0 should always start at START angle (16.0Â°)
          if (currentTrackIndex === 0) {
            angle = CONFIG.angles.START; // 16.0Â°
          } else {
            const fractions = computeTrackFractions();
            const trackStart = fractions[currentTrackIndex]?.start || 0;
            angle = CONFIG.angles.START + (CONFIG.angles.END - CONFIG.angles.START) * trackStart;
          }
        } else {
          // During playback, calculate position based on track progress
          const globalFraction = getGlobalFraction();
          angle = CONFIG.angles.START + (CONFIG.angles.END - CONFIG.angles.START) * globalFraction;
        }
      }
      tonearm.style.transform = `rotate(${angle}deg)`;
    }

    function updateProgress() {
      if (audio.duration) {
        const progress = audio.currentTime / audio.duration;
        progressFill.style.width = `${progress * 100}%`;
        updateTonearm();
      }
    }

    function updateButtons() {
      // Never disable buttons - they all work in any state
    }

    function updatePlaylist() {
      playlistEl.innerHTML = tracks.map((track, index) => `
        <button class="track-item ${index === currentTrackIndex ? 'active' : ''}" 
                onclick="selectTrack(${index})"
                aria-label="Play ${track.title}">
          <span class="track-number">${index + 1}</span>
          <div class="track-details">
            <div class="title">${track.title}</div>
            <div class="artist">${track.artist}</div>
          </div>
          ${index === currentTrackIndex && isPlaying ? `
            <div class="visualizer">
              <span></span>
              <span></span>
              <span></span>
            </div>
          ` : ''}
        </button>
      `).join('');
    }

    function selectTrack(index) {
      currentTrackIndex = index;
      loadTrack(index);
    }

    // Make selectTrack available globally
    window.selectTrack = selectTrack;

    // ============ EVENT LISTENERS ============
    playBtn.addEventListener('click', playTrack);
    stopBtn.addEventListener('click', stopTrack);
    prevBtn.addEventListener('click', prevTrack);
    nextBtn.addEventListener('click', nextTrack);

    audio.addEventListener('timeupdate', updateProgress);
    
    audio.addEventListener('ended', () => {
      // Auto-advance to next track, wrapping to track 1 at end
      if (currentTrackIndex < tracks.length - 1) {
        currentTrackIndex++;
      } else {
        // Wrap back to first track
        currentTrackIndex = 0;
      }
      loadTrack(currentTrackIndex);
      // Keep playing
      audio.play();
    });

    // Keyboard controls
    let calibrationMode = false;
    let adjustTarget = 'platter';

    document.addEventListener('keydown', (e) => {
      if (!calibrationMode) {
        if (e.code === 'Space') {
          e.preventDefault();
          if (isPlaying) {
            stopTrack();
          } else {
            playTrack();
          }
        } else if (e.code === 'ArrowLeft') {
          prevTrack();
        } else if (e.code === 'ArrowRight') {
          nextTrack();
        }
        return;
      }

      // Calibration mode keyboard controls
      const step = e.shiftKey ? 1.0 : e.altKey ? 0.02 : 0.1;
      
      switch (e.key) {
        case 'Escape':
          exitCalibration();
          break;
        case 'Tab':
          e.preventDefault();
          const targets = ['platter', 'tonearm', 'pivot', 'angles'];
          const currentIndex = targets.indexOf(adjustTarget);
          adjustTarget = targets[(currentIndex + 1) % targets.length];
          updateCalibrationUI();
          break;
        case 'ArrowLeft':
          e.preventDefault();
          if (adjustTarget === 'platter') CONFIG.platter.leftPct = Math.max(0, CONFIG.platter.leftPct - step);
          if (adjustTarget === 'tonearm') CONFIG.tonearm.rightPct = Math.max(0, CONFIG.tonearm.rightPct + step);
          if (adjustTarget === 'pivot') CONFIG.tonearm.pivotXPct = Math.max(0, CONFIG.tonearm.pivotXPct - step);
          if (adjustTarget === 'angles') CONFIG.angles.REST -= step;
          saveAndUpdateConfig();
          break;
        case 'ArrowRight':
          e.preventDefault();
          if (adjustTarget === 'platter') CONFIG.platter.leftPct = Math.min(100, CONFIG.platter.leftPct + step);
          if (adjustTarget === 'tonearm') CONFIG.tonearm.rightPct = Math.max(0, CONFIG.tonearm.rightPct - step);
          if (adjustTarget === 'pivot') CONFIG.tonearm.pivotXPct = Math.min(100, CONFIG.tonearm.pivotXPct + step);
          if (adjustTarget === 'angles') CONFIG.angles.REST += step;
          saveAndUpdateConfig();
          break;
        case 'ArrowUp':
          e.preventDefault();
          if (adjustTarget === 'platter') CONFIG.platter.topPct = Math.max(0, CONFIG.platter.topPct - step);
          if (adjustTarget === 'tonearm') CONFIG.tonearm.topPct = Math.max(0, CONFIG.tonearm.topPct - step);
          if (adjustTarget === 'pivot') CONFIG.tonearm.pivotYPct = Math.max(0, CONFIG.tonearm.pivotYPct - step);
          if (adjustTarget === 'angles') CONFIG.angles.START += step;
          saveAndUpdateConfig();
          break;
        case 'ArrowDown':
          e.preventDefault();
          if (adjustTarget === 'platter') CONFIG.platter.topPct = Math.min(100, CONFIG.platter.topPct + step);
          if (adjustTarget === 'tonearm') CONFIG.tonearm.topPct = Math.min(100, CONFIG.tonearm.topPct + step);
          if (adjustTarget === 'pivot') CONFIG.tonearm.pivotYPct = Math.min(100, CONFIG.tonearm.pivotYPct + step);
          if (adjustTarget === 'angles') CONFIG.angles.START -= step;
          saveAndUpdateConfig();
          break;
        case '[':
          e.preventDefault();
          if (adjustTarget === 'platter') CONFIG.platter.sizePct = Math.max(1, CONFIG.platter.sizePct - step);
          if (adjustTarget === 'tonearm') CONFIG.tonearm.lengthScale = Math.max(0.5, CONFIG.tonearm.lengthScale - 0.05);
          if (adjustTarget === 'angles') CONFIG.angles.END -= step;
          saveAndUpdateConfig();
          break;
        case ']':
          e.preventDefault();
          if (adjustTarget === 'platter') CONFIG.platter.sizePct = Math.min(100, CONFIG.platter.sizePct + step);
          if (adjustTarget === 'tonearm') CONFIG.tonearm.lengthScale = Math.min(2.0, CONFIG.tonearm.lengthScale + 0.05);
          if (adjustTarget === 'angles') CONFIG.angles.END += step;
          saveAndUpdateConfig();
          break;
        case '-':
        case '_':
          e.preventDefault();
          if (adjustTarget === 'tonearm') CONFIG.tonearm.widthPct = Math.max(1, CONFIG.tonearm.widthPct - step);
          saveAndUpdateConfig();
          break;
        case '=':
        case '+':
          e.preventDefault();
          if (adjustTarget === 'tonearm') CONFIG.tonearm.widthPct = Math.min(100, CONFIG.tonearm.widthPct + step);
          saveAndUpdateConfig();
          break;
      }
    });

    // ============ CALIBRATION FUNCTIONS ============
    function saveAndUpdateConfig() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(CONFIG));
      updateCalibrationUI();
      applyConfigToElements();
    }

    function applyConfigToElements() {
      // Update platter position and size
      platter.style.left = `${CONFIG.platter.leftPct}%`;
      platter.style.top = `${CONFIG.platter.topPct}%`;
      platter.style.width = `${CONFIG.platter.sizePct}%`;
      
      // Update tonearm position and size
      tonearm.style.right = `${CONFIG.tonearm.rightPct}%`;
      tonearm.style.top = `${CONFIG.tonearm.topPct}%`;
      tonearm.style.width = `${CONFIG.tonearm.widthPct}%`;
      tonearm.style.height = 'auto';
      tonearm.style.transformOrigin = `${CONFIG.tonearm.pivotXPct}% ${CONFIG.tonearm.pivotYPct}%`;
      
      const tonearmImg = tonearm.querySelector('img');
      if (tonearmImg) {
        tonearmImg.style.transform = `scaleY(${CONFIG.tonearm.lengthScale})`;
        tonearmImg.style.transformOrigin = `${CONFIG.tonearm.pivotXPct}% ${CONFIG.tonearm.pivotYPct}%`;
      }
      
      updateTonearm();

      if (calibrationMode) {
        const platterRing = document.getElementById('platterRing');
        platterRing.style.left = `${CONFIG.platter.leftPct}%`;
        platterRing.style.top = `${CONFIG.platter.topPct}%`;
        platterRing.style.width = `${CONFIG.platter.sizePct}%`;
        platterRing.style.height = `${CONFIG.platter.sizePct}%`;

        const tonearmPivot = document.getElementById('tonearmPivot');
        tonearmPivot.style.right = `${CONFIG.tonearm.rightPct}%`;
        tonearmPivot.style.top = `${CONFIG.tonearm.topPct}%`;
        tonearmPivot.style.width = `${CONFIG.tonearm.widthPct}%`;
        const pivotMarker = tonearmPivot.querySelector('.crosshair-h').parentElement;
        pivotMarker.style.left = `${CONFIG.tonearm.pivotXPct}%`;
        pivotMarker.style.top = `${CONFIG.tonearm.pivotYPct}%`;
      }
    }

    function updateCalibrationUI() {
      document.getElementById('platterInfo').textContent = 
        `Platter: L:${CONFIG.platter.leftPct.toFixed(1)}% T:${CONFIG.platter.topPct.toFixed(1)}% Size:${CONFIG.platter.sizePct.toFixed(1)}%`;
      document.getElementById('tonearmInfo').textContent = 
        `Tonearm: R:${CONFIG.tonearm.rightPct.toFixed(1)}% T:${CONFIG.tonearm.topPct.toFixed(1)}% W:${CONFIG.tonearm.widthPct.toFixed(1)}% Len:${CONFIG.tonearm.lengthScale.toFixed(2)}`;
      document.getElementById('pivotInfo').textContent = 
        `Pivot: X:${CONFIG.tonearm.pivotXPct.toFixed(1)}% Y:${CONFIG.tonearm.pivotYPct.toFixed(1)}%`;
      document.getElementById('anglesInfo').textContent = 
        `Angles: REST:${CONFIG.angles.REST.toFixed(1)}Â° START:${CONFIG.angles.START.toFixed(1)}Â° END:${CONFIG.angles.END.toFixed(1)}Â°`;
      document.getElementById('currentTarget').textContent = adjustTarget;

      // Highlight active target
      document.querySelectorAll('.config-values > div').forEach((el, i) => {
        const targets = ['platter', 'tonearm', 'pivot', 'angles'];
        el.classList.toggle('active', targets[i] === adjustTarget);
      });
    }

    function copyConfig() {
      const configText = JSON.stringify(CONFIG, null, 2);
      navigator.clipboard.writeText(configText);
      alert('Config copied to clipboard!');
    }

    function resetConfig() {
      CONFIG = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
      saveAndUpdateConfig();
    }

    function forceDefaults() {
      // Clear all localStorage entries
      try {
        localStorage.removeItem('vinyl-player-config');
        localStorage.removeItem('vinyl-player-config-v2');
        localStorage.removeItem(STORAGE_KEY);
      } catch {}
      CONFIG = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
      saveAndUpdateConfig();
    }

    // Make functions available globally
    window.copyConfig = copyConfig;
    window.resetConfig = resetConfig;
    window.forceDefaults = forceDefaults;
    window.exitCalibration = exitCalibration;

    function exitCalibration() {
      calibrationMode = false;
      document.getElementById('calibrationOverlay').style.display = 'none';
    }

    function enterCalibrationMode() {
      calibrationMode = true;
      document.getElementById('calibrationOverlay').style.display = 'block';
      updateCalibrationUI();
      applyConfigToElements();
    }

    // Reference image upload
    document.getElementById('refImageInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          const refImage = document.getElementById('referenceImage');
          refImage.src = event.target.result;
          refImage.style.display = 'block';
          document.getElementById('opacityControl').style.display = 'block';
        };
        reader.readAsDataURL(file);
      }
    });

    // Opacity slider
    document.getElementById('opacitySlider').addEventListener('input', (e) => {
      const opacity = e.target.value;
      document.getElementById('opacityValue').textContent = opacity;
      document.getElementById('referenceImage').style.opacity = opacity / 100;
    });

    // Check for calibration and reset in URL
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('resetConfig') === '1') {
      forceDefaults();
    }
    if (urlParams.get('calibrate') === '1') {
      enterCalibrationMode();
    }

    // ============ INITIALIZATION ============
    loadTrack(0);
    updateTonearm(0);
    applyConfigToElements(); // Apply CONFIG positioning on load
  </script>
</body>
</html>
